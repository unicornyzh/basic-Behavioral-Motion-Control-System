// window
#include "stdafx.h"

// standard
#include <assert.h>
#include <math.h>
#include<iostream>

// glut
#include <GL/glut.h>
using namespace std;
//================================
// global variables
//================================
// screen size
int g_screenWidth = 0;
int g_screenHeight = 0;

//Boids total numebr
static int boids_n = 20;
//Boids initial position , 3 numbers represent the position x,y,z in world Cartisian System
static GLfloat boids_p_init[100][3] = {
	{2.3f,6.1f,4.4f },
	{ 3.2f,1.5f,3.1f },
	{ 0.7f,6.3f,-1.7f },
	{ -2.6f,8.5f,-2.5f },
	{ 0.3f,9.1f,2.7f },
	{ -0.4f,8.8f,4.1f },
	{ -0.6f,2.3f,4.4f },
	{ 5.3f,5.4f,4.1f },
	{ 0.3f,4.5f,5.8f },
	{ 3.9f,7.7f,3.1f },
	{ 0.2f,10.6f,1.3f },
	{ 4.3f,2.5f,2.0f },
	{ -1.9f,7.6f,-0.6f },
	{ 0.4f,10.2f,-1.3f },
	{ 1.4f,4.8f,2.2f },
	{ 0.0f,5.7f,4.6f },
	{ 5.3f,9.9f,2.0f },
	{ -2.2f,8.1f,-1.7f },
	{ 1.7f,2.6f,5.0f },
	{ 0.2f,9.9f,-0.2f }

};

//the matrix for max 100 boids, each row is one M for one boids
GLfloat boidsM[100][16];

//the matrix for the leading boid implementing glMatrixMult
static GLfloat leaderM[16] = { 0 };


// boids velocity and current postion
GLfloat boids_v[100][3] = {};
GLfloat boids_p[100][3] = {};


// velocity generated by each constrain
GLfloat v_lf[3] = { 0 };   //leader following
GLfloat v_fc[3] = { 0 };   //flock centering
GLfloat v_ca[3] = { 0 };   //collison avoid
GLfloat v_vm[3] = { 0 };   //velocity matching

// color for all boids, decided by number;
GLfloat boid_color[100][3];



// Number of Points for Spline
static int points = 0; //control points index started from 0
int p_number = 7; //The total number of control points

// time variables for generate Q(t)
static GLfloat t = 0;

// spacing (dt) for initial speed and speed control 
static GLfloat dt = 0.04;

// The matrix of boid implement
static GLfloat M[16] = { 0 };
//facing track
static GLfloat tempM[3] = { 0 };

// vectors for computing tangent orientation
static GLfloat tangent[3] = { 0 };
static GLfloat binormal[3] = { 0 };
static GLfloat normal[3] = { 0 };
static GLfloat loopIndex = 0;

// The Catmull-Rom Spline coefficient Marix
static GLfloat CRSplineM[16] = { -0.5f, 1.0f, -0.5f, 0.0f,	  
1.5f, -2.5f, 0.0f, 1.0f,     
-1.5f, 2.0f, 0.5f, 0.0f,      
0.5f, -0.5f, 0.0f, 0.0f };    

// The B Spline coefficient Marix
static GLfloat BSplineM[16] = { -1.0f / 6.0f, 3.0f / 6.0f, -3.0f / 6.0f, 1.0f / 6.0f, 
3.0f / 6.0f, -6.0f / 6.0f, 0.0f / 6.0f, 4.0f / 6.0f,  
-3.0f / 6.0f, 3.0f / 6.0f, 3.0f / 6.0f, 1.0f / 6.0f, 
1.0f / 6.0f, 0.0f / 6.0f, 0.0f / 6.0f, 0.0f / 6.0f };

//Points in Quaternions the first 4 numbers represent w, x, y, z in quaternion, and the rest 3 numbers represent the position x,y,z in world Cartisian System
//There are 7 points for defualt sample
static GLfloat point_quaternion[100][7] = { { 1, 0, 0, 0,13,-19,4 },   //point 1
{ 0, 1, 0, 0, 0,-16,9 },  //point 2
{ 0, 0, 1, 0,-11,14,-18 },   //point 3
{ 0, 0, 0, 1,-3,0,17 }, //point 4
{ 0, 0, 1, 0,16,1,10 },    //point 5
{ 0, 1, 0, 0, -3,-1,0 },  //point 6
{ 1, 0, 0, 0, -19,0,-5 } }; //point 7 }; 

//Pionts 3 numbers represent the position x,y,z in world Cartisian System
static GLfloat point[100][3] = { { 8, 2, -20 },
{ -8, -2, -20 },
{ -5, -6, -10 },
{ 5, -8, -10 },
{ 3, -10, -5 },
{ -3, -14, -5 },
{ 1, -18, -3 }
};






//=====================================================================
// Support Functions Part:
//=====================================================================


//=====================================================================
//Produce 0 to 1 random number;
//=====================================================================
GLfloat Random()
{
	return (GLfloat)rand() / (GLfloat)RAND_MAX;
}


//==================================================================================================
// Blending Function : Q(t) = T*M*G, finding out the vector position of time t
//==================================================================================================
GLfloat blend(GLfloat T[4], GLfloat MS[16], GLfloat G[4])
{
	// B[4] is the result of T*M
	GLfloat B[4] = { 0 };
	B[0] = T[0] * MS[0] + T[1] * MS[1] + T[2] * MS[2] + T[3] * MS[3];
	B[1] = T[0] * MS[4] + T[1] * MS[5] + T[2] * MS[6] + T[3] * MS[7];
	B[2] = T[0] * MS[8] + T[1] * MS[9] + T[2] * MS[10] + T[3] * MS[11];
	B[3] = T[0] * MS[12] + T[1] * MS[13] + T[2] * MS[14] + T[3] * MS[15];

	// Generate the result of T*M*G
	GLfloat Qt = B[0] * G[0] + B[1] * G[1] + B[2] * G[2] + B[3] * G[3];

	return Qt;
}

//=====================================================================
// Vector Normalization : normalize the vector for tangent calculation
//=====================================================================
void Normalization(GLfloat N_tempV[3])
{
	GLfloat squa_quaterion = N_tempV[0] * N_tempV[0] + N_tempV[1] * N_tempV[1] + N_tempV[2] * N_tempV[2];
	if (squa_quaterion != 0) // avoid being divided by 0
	{
		GLfloat base_quaternion = sqrt(squa_quaterion);
		N_tempV[0] = N_tempV[0] / base_quaternion;
		N_tempV[1] = N_tempV[1] / base_quaternion;
		N_tempV[2] = N_tempV[2] / base_quaternion;
	}
}

//=====================================================================
// Vector Multiply : two vectors' cross product
//=====================================================================
void VectorMult(GLfloat TempV1[3], GLfloat TempV2[3], GLfloat VResult[3])
{
	VResult[0] = TempV1[1] * TempV2[2] - TempV1[2] * TempV2[1];
	VResult[1] = TempV1[2] * TempV2[0] - TempV1[0] * TempV2[2];
	VResult[2] = TempV1[0] * TempV2[1] - TempV1[1] * TempV2[0];
}


//==================================================================================================
// Quaternion to Rotation Matrix : generate Rotation Matrix with Given Quaternion and Position
//==================================================================================================
void QuaternionRoatationM(GLfloat Q_tempM[7], GLfloat R[16])
{
	GLfloat w = Q_tempM[0];
	GLfloat x = Q_tempM[1];
	GLfloat y = Q_tempM[2];
	GLfloat z = Q_tempM[3];
	R[0] = 1.0f - 2.0f*y*y - 2.0f*z*z; //column1 row1
	R[1] = 2.0f*x*y + 2.0f*w*z;        //....... row2
	R[2] = 2.0f*x*z - 2.0f*w*y;		   //....... row3
	R[3] = 0.0f;					   //....... row4
	R[4] = 2.0f*x*y - 2.0f*w*z;		   //column2 row1
	R[5] = 1.0f - 2.0f*x*x - 2.0f*z*z; //....... row2
	R[6] = 2.0f*y*z + 2.0f*w*x;		   //....... row3
	R[7] = 0.0f;					   //....... row4
	R[8] = 2.0f*x*z + 2.0f*w*y;		   //column3 row1
	R[9] = 2.0f*y*z - 2.0f*w*x;		   //....... row2
	R[10] = 1.0f - 2.0f*x*x - 2.0f*y*y;//....... row3
	R[11] = 0.0f;					   //....... row4
	R[12] = Q_tempM[4];				   //column4 row1
	R[13] = Q_tempM[5];			       //....... row2
	R[14] = Q_tempM[6];			       //....... row3
	R[15] = 1.0f;					   //....... row4
}


//=====================================================================
// Distance: Calculate the distances between two balls
//=====================================================================
GLfloat Distance(GLfloat Tempv_leader[3], GLfloat Tempv_lflockc[3]) {

	GLfloat Distance = sqrt((Tempv_leader[0] - Tempv_lflockc[0])*(Tempv_leader[0] - Tempv_lflockc[0]) + (Tempv_leader[1] - Tempv_lflockc[1])*(Tempv_leader[1] - Tempv_lflockc[1]) + (Tempv_leader[2] - Tempv_lflockc[2])*(Tempv_leader[2] - Tempv_lflockc[2]));
	return Distance;

}

//=====================================================================
//Constrain Part:Leader following>Flock centering>Collision avoidance>Velocity matching (with nearby boids) 
//=====================================================================

//=======================================================
//Leader following: flocks following the leading movement
//=======================================================
void Leader_following(int index)
{
	for (int i = 0; i < 3; i++)
	{
		v_lf[i] = (leaderM[12 + i] - boidsM[index][12 + i]) / 300;
	}
}
//=====================================================================
//Flock_centering : Flock centering, current boid centering in the center of flock
//=====================================================================
void Flock_centering(int index)
{

	GLfloat all[3] = {};
	GLfloat center[3] = {};
	for (int i = 0; i <  boids_n; i++)
	{
		// Adding up all the boids position
		all[0] += boidsM[i][12];
		all[1] += boidsM[i][13];
		all[2] += boidsM[i][14];

		// Calculating the average as the center position of the rest boids
		center[0] = (all[0] - boidsM[index][12]) / ( boids_n - 1);
		center[1] = (all[1] - boidsM[index][13]) / ( boids_n - 1);
		center[2] = (all[2] - boidsM[index][14]) / ( boids_n - 1);
	}

	//generating the volecity for rule 1
	for (int i = 0; i < 3; i++)
	{
		v_fc[i] = (center[i] - boidsM[index][12 + i]) / 200;
	}
}

//=====================================================================
// Collision_aviod: Collision avoidance, keep a distance between current boids with others.
//=====================================================================
void Collision_aviod(int index)
{
	for (int i = 0; i <  boids_n; i++)
	{
		if (i != index)
		{
			if (Distance(boids_p[index], boids_p[i])< 4)
			{
				for (int j = 0; j < 3; j++)
				{
					v_ca[j] = (v_fc[j] - (boids_p[i][j] - boids_p[index][j])) / 200;
				}
			}
		}
	}
}

//=====================================================================
// Velocity_matching: keep current boids the same with nearby boids
//=====================================================================
void Velocity_matching(int index)
{
	GLfloat all[3] = {};
	GLfloat average[3] = {};
	for (int i = 0; i <  boids_n; i++)
	{
		// Adding up all the boids velocity
		all[0] += boids_v[i][0];
		all[1] += boids_v[i][1];
		all[2] += boids_v[i][2];

		// Calculating the average velocity of the rest boids
		average[0] = (all[0] - boids_v[index][0]) / ( boids_n - 1);
		average[1] = (all[1] - boids_v[index][1]) / ( boids_n - 1);
		average[2] = (all[2] - boids_v[index][2]) / ( boids_n - 1);
	}

	//generating the volecity for rule 3
	for (int i = 0; i < 3; i++)
	{
		v_vm[i] = (average[i] - boids_v[index][i]) / 2000;
	}
}





//==================================================================================================
// init, initial settings of control points numbers, postions
//==================================================================================================
void init(void) {
	//initial the position to each boid's matrix
	for (int i = 0; i< boids_n; i++) {
		boidsM[i][0] = 1.0f;
		boidsM[i][5] = 1.0f;
		boidsM[i][10] = 1.0f;
		for (int j = 0; j<3; j++) {
			boidsM[i][12 + j] = boids_p_init[i][j];
			boids_p[i][j] = boidsM[i][12 + j];
			boid_color[i][j] = Random();
		}
		boidsM[i][15] = 1.0f;
	}
}

//==========================================================================================================
// Quaternion Interpolating Function : generate interpolation with given quaterions, postions and spline styles 
//=========================================================================================================
void q_interpolate(GLfloat position[100][7], GLfloat SplineM[16])
{
	//T matrix T = {t*t*t,t*t,t,1}
	GLfloat TMatrix_q[4] = { t*t*t, t*t, t, 1 };


	// Loop to generate the interpolation track based on 4 points every time
	GLfloat tempM[7];

	for (int i = 0; i < 7; i++)
	{
		// the value of points would be changed by timer
		GLfloat GMatrix_q[4] = { position[points][i],
			position[(points + 1) % p_number][i],
			position[(points + 2) % p_number][i],
			position[(points + 3) % p_number][i] };

		tempM[i] = blend(TMatrix_q, SplineM, GMatrix_q);

	}

	Normalization(tempM);

	QuaternionRoatationM(tempM, leaderM);


}

//==========================================================================================================
// boid Interpolating Function : generate interpolation of boid with give postions and spline styles, facing tagent 
//=========================================================================================================
void boid_interpolate(GLfloat position[100][3], GLfloat SplineM[16], int index)
{
	//T matrix T = {t*t*t,t*t,t,1}
	GLfloat TMatrix_q[4] = { t*t*t, t*t, t, 1 };

	// Set up Tangent T matrix T = {3*t*t,2*t,1,0} 
	GLfloat TangentTMatrix[4] = { 3 * t*t, 2 * t, 1, 0 };

	// Loop to generate the interpolation track based on 4 points every time

	for (int i = 0; i < 3; i++)
	{
		// the value of points would be changed by timer
		GLfloat GMatrix_q[4] = { position[points][i],
			position[(points + 1) % p_number][i],
			position[(points + 2) % p_number][i],
			position[(points + 3) % p_number][i] };

		tempM[i] = blend(TMatrix_q, SplineM, GMatrix_q);
		tangent[i] = blend(TangentTMatrix, SplineM, GMatrix_q);
	}

	//Normalization(tempM);
	Normalization(tangent);
	//QuaternionRoatationM(tempM, leaderM);
	if (points == 0 && loopIndex == 0) // loop starts from the beginning
	{
		GLfloat TempVector[3] = { 1, 0, 0 }; //Pick an arbitrary vector V
		Normalization(TempVector);
		VectorMult(tangent, TempVector, normal);
		Normalization(normal);
		VectorMult(normal, tangent, binormal);
		Normalization(binormal);
		loopIndex++;
	}
	else // loop does not start from the beginning
	{
		VectorMult(tangent, binormal, normal);
		Normalization(normal);
		VectorMult(normal, tangent, binormal);
		Normalization(binormal);
	}

	// Generate the Interpolation Matrix M
	boidsM[index][0] = tangent[0]; // column 1 row 1
	boidsM[index][1] = normal[0]; // ..........row 2
	boidsM[index][2] = binormal[0];// .........row 3
	boidsM[index][3] = 0;			// ........row 4
	boidsM[index][4] = tangent[1]; // column 2 row 1
	boidsM[index][5] = normal[1]; // ..........row 2
	boidsM[index][6] = binormal[1];// .........row 3
	boidsM[index][7] = 0;			// ........row 4
	boidsM[index][8] = tangent[2]; // column 3 row 1
	boidsM[index][9] = normal[2]; // ..........row 2
	boidsM[index][10] = binormal[2];// ........row 3
	boidsM[index][11] = 0;			// ........row 4
	boidsM[index][15] = 1;			// ........row 4

}

//===========================================================================================================================
// Move_boid: single boid movement, applied all constrains
//===========================================================================================================================
void Move_boid(int index) {
	// initialize temperate vector for generated velocity by rules
	GLfloat v_leader[3] = { 0 };
	GLfloat v_flockc[3] = { 0 };
	GLfloat v_collison[3] = { 0 };
	GLfloat v_matching[3] = { 0 };

	Leader_following(index);
	for (int i = 0; i < 3; i++)
	{
		v_leader[i] = v_lf[i];
	}
	Flock_centering(index);
	for (int i = 0; i < 3; i++)
	{
		v_flockc[i] =v_fc[i];
	}
	Collision_aviod(index);
	for (int i = 0; i < 3; i++)
	{
		v_collison[i] = v_ca[i];
	}
    Velocity_matching(index);
	for (int i = 0; i < 3; i++)
	{
		v_matching[i] = v_vm[i];
	}

	// adding up all the velocity generated by rules and renew the position in M matrix for boids
	for (int i = 0; i < 3; i++)
	{
		boids_v[index][i] = boids_v[index][i] + v_leader[i] + v_flockc[i] + v_collison[i] + v_matching[i];
		boids_p[index][i] = boids_p[index][i] + boids_v[index][i] * 0.15;
		boidsM[index][12 + i] = boids_p[index][i];
	}
}

//=======================================================
// Set_leader: set a leader for the flock to following
//=======================================================
void Set_leader()
{
	glPushMatrix();
	q_interpolate(point_quaternion, BSplineM);
	glMultMatrixf(leaderM);
	//glLoadMatrixf(leaderM);
	//glColor3f(255.0f, 255.0f, 255.0f);
	//glutSolidSphere(1, 20, 20);
	//glutSolidCone(0.5, 1, 20, 20);
	glPopMatrix();
	
}
//=======================================================
// Draw_single_boide: draw a single boid
//=======================================================
void Draw_single_boid(int index)
{
	glPushMatrix();
	
	for (int i = 0; i < 16; i++)
	{
		M[i] = boidsM[index][i];
	}
	glMultMatrixf(M);
	//glLoadMatrixf(M);
	glColor3f(boid_color[index][0], boid_color[index][1], boid_color[index][2]);
	//glutSolidSphere(0.3, 20, 20);
	glutSolidCone(0.3,1,20,20);
	glPopMatrix();
}

//=================================================================
// BoidsAnimation: display the leading boid and the following boids
//=================================================================
void Boids_Animation()
{
	Set_leader();
	
	for (int i = 0; i <  boids_n; i++)
	{  
		boid_interpolate(point, BSplineM, i);
		Move_boid(i);
		Draw_single_boid(i);
	}

}

//================================
// timer : triggered every 16ms ( about 60 frames per second )
//================================
void timer(int value) {
	
	// render
	glutPostRedisplay();

	//Set time increase by dt, changing the value of points from 0 to number-1
	t = t + dt;
	if (t >= 1)
	{
		t = 0;
		if (points < p_number -1)
		{
			points++;
		
		}
		else
		{
			points = 0;
		}
	}
	// reset timer
	glutTimerFunc(16, timer, 0);
}

//================================
// render
//================================
void render(void) {
	// clear buffer
	glClearColor(0.0, 0.0, 0.0, 1.0);
	glClearDepth(1.0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	// render state
	glEnable(GL_DEPTH_TEST);
	glShadeModel(GL_SMOOTH);

	// enable lighting
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);

	// light source attributes
	GLfloat LightAmbient[] = { 0.9f, 0.3f, 0.3f, 1.0f };
	GLfloat LightDiffuse[] = { 0.4f, 0.4f, 0.4f, 1.0f };
	GLfloat LightSpecular[] = { 0.5f, 0.6f, 0.5f, 1.0f };
	GLfloat LightPosition[] = { 5.0f, 5.0f, 5.0f, 1.0f };

	glLightfv(GL_LIGHT0, GL_AMBIENT, LightAmbient);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, LightDiffuse);
	glLightfv(GL_LIGHT0, GL_SPECULAR, LightSpecular);
	glLightfv(GL_LIGHT0, GL_POSITION, LightPosition);

	// surface material attributes
	GLfloat material_Ka[] = { 1.0f, 1.0f, 0.0f, 1.0f };
	GLfloat material_Kd[] = { 0.46f, 0.47f, 0.54f, 1.0f };
	GLfloat material_Ks[] = { 0.55f, 0.33f, 0.52f, 1.0f };
	GLfloat material_Ke[] = { 0.1f, 0.0f, 0.1f, 1.0f };
	GLfloat material_Se = 10;

	// render objects
	glMaterialfv(GL_FRONT, GL_AMBIENT, material_Ka);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, material_Kd);
	glMaterialfv(GL_FRONT, GL_SPECULAR, material_Ks);
	glMaterialfv(GL_FRONT, GL_EMISSION, material_Ke);
	glMaterialf(GL_FRONT, GL_SHININESS, material_Se);

	// modelview matrix
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	gluLookAt(10, 15.0, 15.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

	
	
	// disable lighting
	glDisable(GL_LIGHT0);
	glDisable(GL_LIGHTING);

	// animation
	Boids_Animation();
	
	
	// swap back and front buffers
	glutSwapBuffers();
}

//================================
// keyboard input
//================================
void keyboard(unsigned char key, int x, int y) {
	switch (key)
	{
	  //reset dt to the default value (0.01)
	  case 'r':
		dt= 0.01;
		break;
	}
}
//use special key to switch different animation effect and speed control
void special_key(int key, int x, int y) {
	switch (key)
	{
//following for speed control
//speed up, increase dt
	case GLUT_KEY_UP:
		dt += 0.001;
		break;
//speed down, decrease dt
	case GLUT_KEY_DOWN:
		if((dt-0.01)>0)
		dt -= 0.001;
		break;
	}
	glutPostRedisplay();
}
//================================
// reshape : update viewport and projection matrix when the window is resized
//================================
void reshape(int w, int h) {
	// screen size
	g_screenWidth = w;
	g_screenHeight = h;

	// viewport
	glViewport(0, 0, (GLsizei)w, (GLsizei)h);

	// projection matrix
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	gluPerspective(65.0, (GLfloat)w / (GLfloat)h, 1.0, 200.0);
}

//================================
// main
//================================

int main(int argc, char** argv) {
	// create opengL window
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
	glutInitWindowSize(800, 600);
	glutInitWindowPosition(100, 100);
	glutCreateWindow("lab4");

	init();

	// set callback functions
	glutDisplayFunc(render);
	glutReshapeFunc(reshape);
	glutKeyboardFunc(keyboard);
	glutSpecialFunc(special_key);
	glutTimerFunc(16, timer, 0);

	// main loop
	glutMainLoop();

	return 0;
}